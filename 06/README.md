# Ch06 어셈블러

- **어셈블러** : 실행 가능한 2진 코드를 생성하는 프로그램 (어셈블리 명령 - 2진 코드 직접 대응), 번역 기능이 있는 텍스트 처리 프로그램
- **기호 테이블**(symbol table) : 사용자 정의 기호를 물리적 주소에 연결하고 관리하는 기능

<br>

## 6.1 배경

### 기계어

- 기호형(symbolic) 언어 = 어셈블리(assembly)
    - 변수(variable) : 번역기는 '자동적으로' 프로그래머가 변수명으로 사용한 기호를 주소에 할당 (기호가 동일한 주소로 분석되는 한, 할당된 주소의 실제 값 중요X)
    - 레이블(label) : 프로그래머는 프로그램 내 다양한 위치를 기호로 표시(mark) 가능
    
    ⇒ 기호 → 주소 변환 작업 복잡(사용자 정의 변수, 기호 레이블의 경우)
    
- 2진(binary) 형식

### 기계어 명세(machine language specification)

1. **구문 분석**을 통해 기호 명령 내 필드들을 식별
2. 각 필드에 대응하는 **기계어 비트를 생성**
3. 모든 **기호 참조**를 메모리 주소를 가리키는 **숫자**로 바꿈 
4. **2진 코드들을 조립**하여 완전한 기계 명령어로 바꿈 

<br>

## 6.2 핵 어셈블리

### 2진 코드(.hack) 파일

- 각 라인마다 16개의 '0'과 '1'로 된 ASCII 문자열 = 16비트 기계어 명령어 하나
- **n**번째 라인의 2진 코드는 명령어 메모리 주소 **n**에 저장 (프로그램 라인 번호, 메모리 주소 모두 0에서 시작)

### 어셈블리어(.asm) 파일

- 명령어(instruction)나 기호 선언(symbol declaration) 라인들로 구성
    - 명령어 : A-명령어, C-명령어
    - (Symbol) : 의사명령, Symbol 을 프로그램 다음 명령어가 저장되는 메모리 위치에 연결, 해당 기계어 코드 생성X

<br>

## 6.2.2 명령어

- 주소 명령어(addressing instruction, A-명령어) : @value
    - value는 음수가 아닌 10진수
    - 또는 그런 숫자를 참조하는 기호
    - instruction[15]는 **0**
- 계산 명령어(compute instruction, C-명령어) : dest=comp;jump
    - dest나 jump 필드 공란 가능
    - dest가 공란이면 '=' 생략 가능
    - jump가 공란이면 ';' 생략 가능
    - instruction[15]는 **1**

<br>

## 6.2.3 기호

상수나 기호를 이용해 메모리 주소 참조 

- 선언 기호(predefined symbol)
    
    |**레이블**|**RAM 주소**|
    |----------|------------|
    |SP = R0   |           0|
    |LCL = R1  |           1|
    |ARG = R2  |           2|
    |THIS = R3 |           3|
    |THAT = R4 |           4|
    |R0-R15    |      0 - 15|
    |SCREEN    |       16384|
    |KBD       |       24576|
    
- 레이블 기호
    
    의사 명령 (Xxx) : 기호 Xxx가 프로그램의 다음 명령이 있는 명령어 메모리 위치를 참조하도록 정의, 어디서든 사용 가능(정의된 라인 앞에서도)
    
- 변수 기호
    
    순서대로 RAM 주소 16(0x0010)에서 시작하는 메모리 주소에 차례대로 매핑 

<br>

## 6.3 구현

- Parser 모듈 : 입력 구문 분석
- Code 모듈 : 모든 어셈블리 연상기호들의 2진 코드 제공
- SymbolTable 모듈 : 기호 처리
- main 프로그램 : 전체 번역 과정 실행

<br>

## 6.3.1 Parser 모듈

어셈블리 명령들을 부분들(**필드**, **기호**)로 분해, 모든 공백과 주석 제거

### 루틴 (함수)

- 생성자(Constructor)/초기자(Initializer) : 입력 파일/스트림을 열고 분석할 준비
- hasMoreCommands : 입력에 명령어 더 있나?
- advance : 입력에서 다음 명령을 읽어서, 현재 명령으로 만듦 (hasMoreCommands()가 참일 때만 호출)
- commandType : 현재 명령의 타입 반환 (반환값 : A_COMMAND, C_COMMAND, L_COMMAND)
- symbol : @Xxx나 (Xxx)의 현재 명령에서 기호 또는 10진수 Xxx 반환 (commandType()이 A_COMMAND나 L_COMMAND일 때만 호출)
- dest : 현재 C-명령의 dest 연상기호 반환 (commandType()이 C_COMMAND일 때만 호출)
- comp : 현재 C-명령에서 comp 연상기호 반환 (commandType()이 C_COMMAND일 때만 호출)
- jump : 현재 C-명령에서 jump 연상기호 반환 (commandType()이 C_COMMAND일 때만 호출)

<br>

## 6.3.2 Code 모듈

핵 어셈블리 언어의 연상기호를 2진 코드로 번역 

### 루틴 (함수)

- dest : dest 연상기호의 2진 코드 반환
- comp : comp 연상기호의 2진 코드 반환
- jump : jump 연상기호의 2진 코드 반환

⇒ 여기까지 기호를 처리하지 **않는** 어셈블러 (Prog.asm의 @Xxx 형식 명령어에서 Xxx가 기호가 아닌 10진수, (Xxx) 같은 레이블 명령 포함X한 경우에 대해)

<br>

## 6.3.4 SymbolTable 모듈

기호 테이블 : 기호와 RAM과 ROM 주소들의 대응관계 관리 (기호 레이블 - 숫자 주소 간의 대응관계 기억)

### 루틴

- Constructor : 새로운 빈 기호 테이블 생성
- addEntry : (symbol, address) 쌍을 테이블에 추가
- contains : 기호 테이블이 주어진 symbol 포함?
- GetAddress : symbol과 연결된 주소 반환

### 기호 처리 어셈블러

⇒ 처음부터 끝까지 코드를 두 번 읽는 **2패스** 어셈블러 : **1차**로 코드를 읽을 때는 **기호 테이블만 구성**, 아무런 코드 생성X, **2차**로 읽을 때 어셈블러는 기호들을 그에 대응하는 **숫자 주소로 바꾸고 최종 2진 코드 생성** 

### "선언 기호, 레이블, 변수"의 세 가지 기호에 대한 어셈블러의 작용

- 초기화 (**선언 기호** 처리)
    
    기호 테이블을 선언 기호와 그 기호에 미리 할당된 RAM 주소들로 초기화 
    
- 1패스 (**레이블** 처리)
    - 어셈블리 프로그램을 라인 단위로 처음-끝까지 훑으면서 코드 생성X, only 기호 테이블만 구성
    - 현재 명령어 로드될 ROM 주소를 기록하는 **숫자**를 둠
      - 0부터 시작하며 C-명령어나 A-명령어가 나타날 때마다 1씩 증가, but 레이블 의사명령이나 주석이 나오면 증가X
      - 의사명령 (Xxx)가 나올 때마다, 프로그램의 다음 명령을 저장할 ROM 주소와 Xxx를 연결하는 값을 기호 테이블에 새로 입력
- 2패스 (**변수** 처리)
    
    기호가 있는 A-명령어를 만날 때마다 (@Xxx에서 Xxx가 숫자가 아닌 기호인 경우) 기호 테이블에서 Xxx 조회 
    
    → 테이블에 해당 기호 **있다면** → 그 기호에 대응되는 숫자 값으로 교체 → 해당 명령 번역 완료 
    
    → **없다면**, 해당 기호 새로운 변수 → 기호 테이블에 (Xxx, n) 쌍 추가 (n : 다음에 가용한 RAM 주소)
