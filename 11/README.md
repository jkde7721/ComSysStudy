# Ch11 컴파일러 II: 코드 생성

## 11.1.1 데이터 번역

- 변수 컴파일 시, 대상 플랫폼에서 변수 타입이 적절하게 수용되도록 매핑
- 변수의 **종류**에 따라 **생명주기**, **범위** 관리

### 기호 테이블

식별자마다 필요한 관련 정보 저장 ex. 범위, 이름, 타입, 종류 ...

_*범위 : 식별자가 **인식되는 영역** (바깥쪽 범위에서 안쪽 범위의 정의에 접근X)_

### 변수 처리

변수들의 메모리 할당을 **VM 백엔드에 위임** 

### 배열 처리

**배열 이름** : 메모리에 할당된 RAM 블록의 **시작 주소**를 가리키는 **포인터** 

### 객체 처리

어떤 클래스의 객체 인스턴스는 **필드**와 **메서드**들을 **캡슐화**

⇒ 컴파일러는 필드, 메서드를 다르게 처리 

- **필드**
    - 객체 인스턴스 별로 따로 **복사본** 보관
    - 객체 인스턴스의 필드들은 **연속된 메모리** 위치에 저장
    - 객체들은 **시작 주소**를 담고 있는 **포인터 변수**로 표현 → 시작 주소에서 시작하는 **인덱스**로 필드 접근 가능
- **메서드**
    - 모든 객체 인스턴스에 대해 **하나**의 복사본만 유지 → 각 객체마다 이 하나의 메서드만 호출하도록
    - x.m(y) 메서드 호출 시, 잭 컴파일러는 메서드 m()이 어떤 클래스의 객체 x에 속하는지 찾아야 함 (**컴파일 타임에, 런타임X**)

⇒ 호출된 메서드에 **숨은 인수 형태**로 **객체의 참조 전달** → 객체마다 **똑같은 메서드**로 연산 수행 

```basic
b.mult(5) -> mult(b,5)

// jack
foo.bar(v1,v2,...)
// VM 코드
push foo
push v1
push v2
push ...
call bar
```

<br>

## 11.1.2 명령 번역

### 표현식 평가하기

구분 분석기에서 처리된 파스 트리를 **재귀적인 후위 순회**(post-order traversal) 처리 

⇒ **왼쪽** 서브트리, **오른쪽** 서브트리, **루트** 순서로 순회

### 흐름 제어

- 고수준 언어의 흐름 제어 구조 : **if, while, for, switch**
- 저수준 언어의 흐름 제어 구조 : **조건 goto, 무조건 goto**
