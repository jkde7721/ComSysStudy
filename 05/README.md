# ch05 컴퓨터 아키텍처

## 5.1.2 폰 노이만 구조

![image](https://user-images.githubusercontent.com/65665065/218647063-4184a612-dcdf-4326-938e-b42293bcc287.png)

- 프로그램 영역 - 명령어 저장, 데이터 영역 - 데이터 저장
    
    ⇒ 무작위 접근 구조(random access structure), 2진수로 저장
    
- fetch(연산의 각 단계마다 CPU는 명령어 메모리에서 단어 하나 인출) → decode → execute → store

<br>

## 5.1.4 중앙 처리 장치

### 산술 논리 연산 장치(ALU)

ex. 두 값의 합, 양수 확인, 데이터 단어의 비트 조작 

### 레지스터

CPU 근처의 메모리(고속), 단어 하나 저장

### 제어 장치

명령어 해석, 다음 실행을 위해 인출할 명령어 선택

<br>

## 5.1.5 레지스터

ex. 메모리 주소 j의 내용을 가져오라는 명령어

1. j가 CPU에서 RAM으로 전달
2. 주소가 j인 메모리 레지스터가 선택
3. RAM[j]의 내용 CPU로 전달  

### 데이터 레지스터

CPU의 단기 기억 메모리 기능, 연산의 중간값 임시 저장 

### 주소 지정 레지스터

주소 저장

### 프로그램 계수기 레지스터(PC)

명령어 메모리에서 인출해야 할 다음 명령어 주소

- 보통 다음 명령어 인출 ⇒ PC + 1
- goto n문 존재 ⇒ PC = n

<br>

## 5.1.6 입력과 출력

### 메모리 매핑 I/O

- I/O 장치를 일반적인 메모리 세그먼트처럼 보이도록 하는 것
- 각 I/O 장치마다 메모리 내에 전용 영역 할당되어 '메모리 맵(memory map)' 역할
- 지속적으로 장치의 물리적 상태 **반영** 및 **구동**

<br>

## 5.2.1 핵 하드웨어 플랫폼 명세 개요

명령어 메모리(read only, 새로운 프로그램 실행을 위해 ROM 칩 교체)에 있는 프로그램 실행 

### 주소 명령어

0vvvvvvvvvvvvvvv ⇒ 15비트 vvv...v를 A레지스터에 로드 

### 계산 명령어

111accccccdddjjj

- a 또는 c 비트 : ALU가 어떤 함수 계산?
- d 비트 : ALU 출력 어디에 저장?
- j 비트 : 선택적인 점프 조건
- 현재 명령어 = ROM[PC]

<br>

### 실행(execute)

현재 명령어 비트들은 여러 칩에 동시 전달 → 명령어에 따라 적절히 수행

### 인출(fetch)

다음 인출할 명령어 현재 명령어의 **점프 비트** 및 **ALU 출력**에 따라 결정 

- 점프O ⇒ PC = A 레지스터 값
- 점프X ⇒ PC = PC + 1

<br>

### 핵 하드웨어 플랫폼 구성

**중앙 처리 장치**(CPU), **메모리 칩**(명령어 메모리(ROM), 데이터 메모리, 스크린 메모리 맵, 키보드 메모리 맵)

<br>

### 메모리 칩

- 입력 : in[16], load, address[15]
- 출력 : out[16]
- 기능
    - out(t) = Memory[address(t)] (t)
    - if load(t-1) then Memory[address(t-1)] (t) = in(t-1)

<br>

## 5.2.4 데이터 메모리

- ex. 레지스터 n의 내용 read
    
    메모리의 address 입력 ← n 하고 out 출력 검사 ⇒ 조합 연산(클록 무관)
    
- ex. 레지스터 n에 값 v write
    
    in ← v, address ← n, load 비트 활성화 ⇒ 순차 연산(레지스터 n은 다음 클록 주기 때 v로 change)
    
- 메모리 맵을 통한 CPU와 입/출력 장치 사이의 통신 기능

<br>

## 5.3 핵 컴퓨터 구현

### CPU의 제어 논리

- 명령어 해석(decode) : 명령어 의미 파악
- 명령어 실행(execute) : 컴퓨터의 여러 부품들에 신호 전송
- 명령어 인출(fetch) : 다음 실행할 명령어 알아냄
    
    if jump(t) then PC(t) = A(t-1) else PC(t) = PC(t-1) + 1
    

### 프로그램 재실행

⇒ reset = 1 → 0

- reset = 1 이면, PC = 0 설정
- reset = 0 이면, ROM에 저장된 프로그램 실행
