# Ch07 가상 머신 I: 스택 산술

- **VM** : 다른 컴퓨터 플랫폼 상에서 구현 가능한 **추상적인 컴퓨터**
- vm 언어의 명령어 종류 4가지 : 산술, 메모리 접근, 프로그램 흐름 제어, 서브루틴 호출 명령

<br>

## 7.1.1 가상 머신 패러다임

**컴파일** : 고수준 언어 → 기계어로 번역하는 과정 ⇒ 고수준 언어와 기계어의 특성에 따라 수많은 컴파일러 존재 

- 컴파일러에서 기계 종속성을 분리하는 방법 : 전체 컴파일 과정을 **두 단계**로 쪼개는 것
1. **고수준 언어**의 구문을 분석 → **중간 처리 단계**로 번역 
2. **중간 처리 단계**들을 다시 대상 하드웨어의 **기계어**로 번역 
    
    ⇒ 중간 처리 단계를 명령어로 삼는 가상 머신 정의 필요 
    
<br>

## 7.1.2 스택 머신 모델

- vm은 산술 연산, 메모리 접근 연산, 프로그램 흐름 제어 연산, 서브루틴 호출 연산으로 구성
- “vm 연산의 피연산자와 결과값 어디에 저장? ⇒ **스택**!
- **산술 명령** in 스택 머신 모델 : 스택의 최상단에서 피연산자를 꺼내고(**pop**) 그 결과를 다시 스택의 최상단에 삽입(**push**)
    
    **이 외 다른 명령들** : 스택의 최상단과 지정된 메모리 주소 사이에 데이터 이동 
   
<br>

### 기본 스택 연산

- **push** : 한 개의 데이터 원소를 스택의 최상단에 **추가**하는 연산
- **pop** : 최상단 원소를 꺼낸 후 스택에서 **삭제**하는 연산
    
    ⇒ 후입선출(**LIFO**)
    
<br>

### 스택 방식

- 최상단에 있는 한 항목씩만 접근 가능
- 스택 읽기 : 손실 연산, 스택 쓰기 : 스택의 나머지 부분 변화X

### 기존의 메모리 접근 방식

- 읽기 : 메모리 상태에 아무런 영향X, 쓰기 : 예전 값을 덮어쓰는 손실 연산

### 스택 데이터 구조 구현

- 스택 **배열**, 스택 **포인터**(sp)
    - push x ⇒ `stack[sp] = x;` `sp = sp + 1;`
    - pop x ⇒ `sp = sp - 1;` `return stack[sp];`

### 스택의 두가지 용도

1. 산술 및 논리 연산 처리
2. 서브루틴 호출과 그와 관련한 메모리 할당에 활용 

### 스택 산술

1. 피연산자를 스택에서 꺼냄 (**pop**)
2. 연산 수행 
3. 결과를 다시 스택에 넣음 (**push**)
- `d = (2 - x) * (y + 5)`
    
    ```basic
    push 2
    push x
    sub
    push y
    push 5
    add
    mult
    pop d
    ```
    
- `if (x < 7) or (y = 8)`
    
    ```basic
    push x
    push 7
    lt
    push y
    push 8
    eq
    or
    ```
    
<br>

## 7.2.1 일반

### VM 언어

정수나 불 대수, 포인터로 쓰이는 16비트 데이터 타입 하나만 정의 

- **산술 명령** : 스택에서 산술 및 논리 연산 수행
- **메모리 접근 명령** : 스택과 가상 메모리 세그먼트 사이에 데이터 주고받는 명령
- **프로그램 흐름 명령** : 조건 및 무조건 분기 연산을 가능하게 함
- **함수 호출 명령** : 함수를 호출하고 결과 반환

<br>

### 프로그램 및 명령 구조

- **VM 프로그램**은 한 개 이상의 ***.vm 파일**로 구성, 각 파일은 하나 이상의 **함수**로 구성
    
    ⇒ like 프로그램, 클래스, 메서드에 대응 
    
- .vm 파일 내부에서 **한 라인**은 **하나의 VM 명령**
- 형식
    
    **command**(명령어), **command arg**(인수), **command arg1 arg2**   

<br>

## 7.2.2 산술 및 논리 명령

스택의 나머지 부분에 영향X → only 해당 피연산자를 결과값으로 교체

### 산술 및 논리 스택 명령

|**명령**|         **반환값**      |**설명**|
|--------|-------------------------|--------|
|add     |x + y                    |정수 덧셈|
|sub     |x - y                    |정수 뺄셈|
|neg     |-y                       |산술 부정|
|eq      |true if x = y, else false|같음|
|gt      |true if x > y, else false|초과|
|lt      |true if x < y, else false|미만|
|and     |x And y                  |비트 단위|
|or      |x Or y                   |비트 단위|
|not     |Not y                    |비트 단위|

***true** : -1(0xFFFF), **false** : 0(0x0000)

<br>

## 7.2.3 메모리 접근 명령

8개의 가상 메모리 세그먼트들을 조작하는 메모리 접근 명령 수행 

### 세그먼트

- **argument** : 함수의 **인수**를 저장, 함수가 입력되면 VM이 동적으로 할당
- **local** : 함수의 **지역 변수**를 저장, 함수가 입력되면 VM이 동적으로 할당하고 0으로 초기화
- **static** : 같은 .vm 파일 내 모든 함수가 공유하는 **정적 변수** 저장, 각 .vm 파일에 대해 VM이 할당
- **constant** : 0~32767 범위 내 모든 **상수**를 가지는 의사 세그먼트, VM이 에뮬레이션, 프로그램 내 모든 함수에서 접근 가능
- **this, that** : 다목적 세그먼트, **힙** 내 서로 다른 영역에 대응하도록 설정 가능, 힙 상에서 선택된 영역을 조작하는 용도로 사용
- **pointer** : **this**와 **that** 세그먼트의 **기준 주소값**을 가지고 있는 두 개의 입력 세그먼트, 모든 VM 함수는 pointer 0 또는 1을 특정 주소로 설정 가능, this 또는 that 세그먼트가 해당 주소에서 시작하는 힙 영역으로 정렬됨
- **temp** : 일반적 용도의 **임시 변수**를 가지는 고정 8-엔트리 세그먼트, VM 함수 내에서 어떤 목적으로든 사용 가능, 프로그램 내 모든 함수가 공유

<br>

### 메모리 접근 명령

- **push segment index** : segment[index] 값을 스택에 넣음
- **pop segment index** : 최상단 스택 값을 꺼내어 segment[index]에 저장
    
    *segment : 8개 세그먼트 이름 중 하나, index : 음수가 아닌 정수(0부터 시작)

<br>

### 스택

- VM 연산에서 작업 메모리로 쓰임
- 데이터 값은 한 세그먼트에서 다른 세그먼트로 점프하는 대신 스택을 거쳐 이동

### 힙

- VM 뒷단에 존재하는 또 다른 메모리 요소
- 객체와 배열 데이터를 저장하는데 사용되는 RAM 영역의 명칭

<br>

## 7.2.4 프로그램 흐름과 함수 호출 명령 (다음 장에서 더 자세히...)

### 프로그램 흐름 명령

- **label symbol** // 레이블 선언
- **goto symbol** // 무조건 분기
- **if-goto symbol** // 조건 분기

### 함수 호출 명령

- **function functionName nLocals** // 함수 선언, 함수의 지역 변수 개수 지정
- **call functionName nArgs** // 함수 호출, 함수의 인수 개수 지정
- **return** // 호출하는 함수로 제어 되돌림

<br>

## 7.2.5 잭-VM-핵 플랫폼의 프로그램 요소들

잭 컴파일러가 n개의 잭 클래스 파일이 들어 있는 디렉터리에 적용

⇒ n개의 **.jack** 파일 → n개의 **.vm** 파일 → 한 개의 **.asm** 파일 → 한 개의 **.hack** 파일 

<br>

## 7.3 구현

1. 대상 플랫폼에서 VM 환경(스택, 가상 메모리 세그먼트)을 에뮬레이션 
2. 각 VM 명령들을 대상 플랫폼에서 그 명령의 의미대로 수행되는 명령어들로 번역 

### VM 번역기

.vm 파일 묶음을 입력으로 받아 핵 어셈블리 언어로 된 .asm 파일 하나를 출력으로 생성 

### RAM 사용

|**RAM 주소**|**사용법**|
|------------|----------|
|0-15        |16개의 가상 레지스터|
|16-255      |정적 변수(같은 .vm 파일 내 모든 VM 함수에서 사용)|
|256-2047    |스택|
|2048-16383  |힙(객체, 배열 저장)|
|16384-24575 |메모리 매핑 I/O|
|24576-32767 |사용하지 않는 메모리 공간| 

<br>

|**레지스터**|**이름**|**사용법** |
|------------|--------|-----------|
|RAM[0]      | SP     |스택 포인터 : 스택에서 다음 최상위 위치 가리킴|
|RAM[1]      |LCL     |현재 VM 함수의 local 세그먼트의 기저 주소 가리킴|
|RAM[2]      | ARG    |현재 VM 함수의 argument 세그먼트의 기저 주소 가리킴|
|RAM[3]      |THIS    |현재 this 세그먼트의 시작 주소(힙 내부) 가리킴|
|RAM[4]      |THAT    |현재 that 세그먼트의 시작 주소(힙 내부) 가리킴|
|RAM[5-12]   |        |temp 세그먼트의 내용 저장|
|RAM[13-15]  |        |VM 구현에서 다용도 레지스터로 사용|

<br>

### 메모리 세그먼트 매핑

- **local, argument, this, that** : 각각 RAM에 직접 매핑, 전용 레지스터(LCL, ARG, THIS, THAT)에 실제 시작 주소 저장
    
    ⇒ 각 세그먼트의 i번째 항목에 접근 ex. argument 세그먼트의 두번째 항목에 접근 : RAM[2] + 1
    
- **pointer, temp** : RAM 내의 고정 영역으로 바로 매핑, pointer 세그먼트는 RAM 위치 3, 4에, temp 세그먼트는 위치 5~12에 해당
- **constant** : 대상 아키텍쳐의 실제 공간 차지X, VM에서는 단순히 constant i에 대해 상수 i를 제공
- **static** : VM 파일 f에 있는 정적 변수 j → in 어셈블리, f.j 로 번역
    
    ex. Xxx.vm 파일에 push static 3 → @Xxx.3; D=M; D값을 스택에 푸시

<br>

## 7.3.3 프로그램 구조

메인 프로그램, 구문 분석기(Parser), 코드 작성기(CodeWriter)

<br>

### Parser 모듈

.vm 파일 구문 분석 처리, 공백 및 주석 모두 제거 

- **Constructor** : 입력 파일/스트림 open
- **hasMoreCommands** : 입력에 명령 더 있는지 확인
- **advance** : 다음 명령을 읽어들임
- **commandType** : 현재 VM 명령의 타입 반환, (반환값 : C_ARITHMETIC, C_PUSH, C_POP, C_LABEL, C_GOTO, C_IF, C_FUNCTION, C_RETURN, C_CALL)
- **arg1** : 현재 명령의 첫 인수 반환 (C_ARITHMETHIC의 경우 명령 그 자체, C_RETURN의 경우 호출X)
- **arg2** : 현재 명령의 두번째 인수 반환 (C_PUSH, C_POP, C_FUNCTION, C_CALL의 경우만 호출O)

<br>

### CodeWriter 모듈

VM 명령을 핵 어셈블리 코드로 번역 

- **Constructor** : 출력 파일/스트림 open
- **setFileName** : 코드 작성기에게 새로운 VM 파일 번역이 시작되었음을 알림
- **writerArithmetic** : 주어진 산술 명령 → 어셈블리 코드
- **WritePushPop** : 주어진 command(C_PUSH 또는 C_POP) → 어셈블리 코드
- **Close** : 출력 파일 close

<br>

### 메인 프로그램

프로그램 인수가 디렉터리명일 경우, 디렉터리 내 모든 .vm 파일 처리

⇒ 각각의 입력 파일 처리하는 **Parser 여러 개**, 출력 처리하는 **CodeWriter 하나** 필요
