# Ch04 기계어

## 4.1.1 기계

### 기계어

기계 수준의 명령어들로 이루어진 저수준 프로그램을 코딩할 수 있도록 미리 정의된 규칙 

설계 목표 : 대상 하드웨어 플랫폼에서 직접적으로 명령을 실행, 하드웨어를 완전히 제어 

전체 컴퓨터 시스템에서 가장 기본이 되는 인터페이스 

hw - sw의 접점 

프로그래밍 도구 + 하드웨어 플랫폼의 구성 요소 

프로세서와 레지스터들을 이용해서 메모리를 조작할 수 있도록 미리 정의된 규칙 

### 메모리

데이터 혹은 명령어를 저장하는 하드웨어 장치

단어(word) 혹은 위치(location)라 불리는 정해진 폭의 셀들이 연속적으로 배열 → 각각에 유일한 주소O → 주소를 통해 접근 

### 프로세서

중앙 처리 장치(Central Processing Unit, CPU), 특정한 기초 연산들을 수행하는 장치 

ex. 산술 및 논리 연산, 메모리 접근 연산, 제어 또는 분기 연산 

피연산자 : 선택된 메모리 위치(주소), 레지스터에 있는 2진값 

결과값 → 선택된 메모리 주소 또는 레지스터에 저장

### 레지스터

프로세서 바로 옆에 위치 → 프로세서가 명령어와 데이터를 빠르게 조작할 수 있도록 로컬 고속 메모리 역할

## 4.1.2 언어

기계어는 보통 2진 코드와 연상기호 둘다 사용 

어셈블리 언어, 어셈블리 : 2진 명령어를 대신하여 프로그램을 작성할 때 사용하는 기호 표기법 

어셈블러 : 어셈블리를 2진 코드로 번역하는 프로그램 

## 4.1.3 명령

### 산술 및 논리 연산

기초 산술 연산(덧셈, 뺄셈) + 기본적인 불 연산(비트 반전, 비트 이동) 등 

ADD R2, R1, R3 // R2 ← R1 + R3

ADD R2, R1, foo // R2 ← R1 + foo(해당 메모리 주소의 값)

AND R1, R1, R2 // R1 ← R1 & R2

### 메모리 접근

레지스터 외의 특정 메모리 주소 접근(in 산술 및 논리 명령)

로드(load), 저장(store) 명령 : 레지스터와 메모리 사이에 데이터를 이동시키는 명령 

- 주소 지정 모드(addressing mode) : 메모리 단어의 주소를 특정하는 방법
    - 직접 주소 지정 방식(direct addressing)
        - 특정 주소를 직접 쓰거나 그 주소를 나타내는 기호를 활용
            
            LOAD R1, 67 // R1 ← Memory[67]
            
            LOAD R1, address // R1 ← Memory[address] 
            
    - 즉시 주소 지정 방식(immediate addressing)
        - 명령어 코드에 있는 상수를 불러오는데 사용
        - 명령어에 있는 숫자 필드 자체 → 레지스터로 로드
            
            LOAD R1, 67 // R1 ← 67
            
    - 간접 주소 지정 방식(indirect addressing)
        - 명령어에 메모리 주소가 하드코딩 되지 않음
        - 필요한 주소 값을 저장하고 있는 메모리 위치를 참조하는 명령어 사용 → 고급 언어에서 포인터를 다룰 때 사용
        - n = arr[idx]
            
            고수준 프로그램에서 배열 arr를 정의하고 초기화 → 컴파일러는 배열 데이터를 저장할 메모리 세그먼트 할당 → arr 기호가 해당 세그먼트의 시작 주소를 가리키도록 함 
            
        - arr[idx] : 물리적으로 배열의 시작 주소에서 idx만큼 떨어진 메모리 주소에 위치
            
            ADD R1, arr, idx // R1 ← arr + idx
            
            LOAD R2, R1 // R2 ← Memory[R1] 
            
            STR R2, n // n ← R2 
            

### 제어 흐름

- 분기(branching) : 반복, 조건 실행, 서브루틴 호출 등
    
    ⇒ 선택된 주소로 조건별 또는 무조건별로 점프하는 기능O 
    
- 어셈블리 언어 ⇒ **레이블 문법**을 통해 프로그램 내 특정 위치에 기호 지정 가능

## 4.2.1 핵 기계어 명세 개요

### 핵 컴퓨터

CPU, 명령용 메모리, 데이터용 메모리, I/O 장치(스크린, 키보드)

### 메모리 주소 공간

- 명령어 메모리
    
    읽기 전용, 외부적인 방법으로만 프로그램 로드 가능 ex. 필요한 프로그램 미리 ROM 칩에 새기는 방식 
    
- 데이터 메모리
    
    ⇒ 폭 16비트, 주소 공간 15비트 → 최대 32k(2^5*2^10)개의 16비트 단어들에 주소 할당 가능 
    

### 레지스터

: A, D 16비트 레지스터 

- D 레지스터
    
    데이터 값을 저장
    
- A 레지스터
    - 데이터 레지스터(데이터 값), 주소 레지스터(데이터 메모리의 주소, 명령어 메모리의 주소)
    - 데이터 메모리에 직접 접근을 용이하게 하는 용도
        
        핵 문법 
        
        - 핵 명령어 16비트(명령어 내용 자체), 주소 15비트로 표시 → 명령어 내부에 주소 포함X
        - 'M' 레지스터 사용 ⇒ 항상 A레지스터의 현재 값을 주소로 하는 메모리 내 단어 참조
        - D = Memory[516] -1 연산 시, A레지스터에 516 저장 → D = M - 1 명령어 실행
    - 명령어 메모리에 직접 접근하는 용도
        - 핵의 점프 명령어에서 주소 직접 명시X
        - 무조건 A의 현재 값을 주소로 하는 명령어로 점프
        - goto 35 연산 시, A레지스터에 35 저장 → 주소 없이 goto 명령어 실행

- @value
    
    value : 어떤 숫자 또는 그 숫자를 가리키는 기호
    
    ⇒ 어떤 값을 A 레지스터에 저장하라는 명령어 
    

- 연산에 메모리 위치가 관련될 경우
    
    연산하려는 주소를 선택하는 명령어 + 수행하려는 연산 자체를 명시하는 명령어 
    

## 4.2.2 A-명령어

- 주소 명령어(address instruction)
- 컴퓨터가 A 레지스터에 특정 값(15비트)을 저장하도록 명령
- 세가지 용도
    1. 상수를 입력하는 용도 
    2. A 레지스터에 데이터의 주소를 미리 입력해두는 용도 (C-명령어에서 해당 주소에 있는 값 참조)
    3. A 레지스터에 점프할 주소를 미리 입력 (점프 C-명령어 준비)

```c
// 1+...+100 
int i = 1;
int sum = 0;
while(i <= 100) {
    sum += i;
    i++;
}
```

```basic
// ADDs 1+...+100
    @i // i는 어떤 메모리 위치 참조 (주소)
    M=1 // i=1
    @sum // sum은 어떤 메모리 위치 참조 (주소) 
    M=0 // sum=0
(LOOP)
    @i
    D=M // D=i
    @100 // 상수 저장 
    D=D-A // D=i-100
    @END
    D; JGT // if(i-100) > 0 goto END
    @i
    D=M // D=i
    @sum
    M=D+M // sum=sum+i
    @i
    M=M+1 // i=i+1
    @LOOP
    0; JMP // Goto LOOP
(END)
    @END
    0; JMP // 무한 루프(종료)
```

## 4.2.3 C-명령어

- 계산 명령어(compute instruction)
- 무엇을 계산? 계산된 값을 어디에 저장? 그 다음에 할 일 무엇?
- dest=comp;jump
    - dest, jump 공란 가능
        - comp 필드 : ALU가 할 연산이 무엇인지
    - dest 공란이면 '=' 생략
    - jump 공란이면 ';' 생략
- 맨 왼쪽 비트 값 1 ⇒ 해당 명령어가 C-명령어임을 나타내는 코드, 그다음 두 비트 사용X
- dest 필드 : 계산된 값(ALU 출력)을 어디에 저장할지
- jump 필드 : 점프 조건, 다음에 불러와서 실행할 명령어가 무엇인지
    
    ⇒ 형식 : 111a cccc ccdd djjj
    

### 계산 필드(computation field)

- 1개의 a-비트, 6개의 c-비트 ⇒ 총 7비트
    - D-1 : D 레지스터의 현재 값에서 1을 빼는 계산
        
        111**0 0011 10**00 0000
        
    - D|M 값을 계산
        
        111**1 0101 01**00 0000
        
    - 상수 -1을 계산
        
        111**0 1110 10**00 0000
        

### 목적지 필드(destination field)

- 첫번째 d비트 - A 레지스터에 저장
- 두번째 d비트 - D 레지스터에 저장
- 세번째 d비트 - M(Memory[A])에 저장
- Memory[7]의 값을 1만큼 증가시키고 결과값을 D, M에 저장
    
    0000 0000 0000 0111 // @7
    
    1111 1101 1101 1000 // MD=M+1 
    

### 점프 필드(jump field)

- 컴퓨터가 다음에 수행할 일 지시
    - 프로그램에서 다음번 명령을 불러와 실행 (순차)
    - 프로그램 내 다른 곳에 위치한 명령을 불러와 실행 (분기) ⇒ 점프할 주소가 A 레지스터에 이미 저장되었다고 가정
- 세 개의 j 비트 + ALU 출력값 → 점프 여부 결정
    - ALU 출력값 음수 - 첫번째 j비트로 결정
    - ALU 출력값 0 - 두번째 j비트로 결정
    - ALU 출력값 양수 - 세번째 j비트로 결정
        
        ⇒ 8개의 점프 조건O 
        

```basic
//if Memory[3]=5 then goto 100
//else goto 200

@3 // 주소 
D=M // D=Memory[3] 
@5 // 상수 
D=D-A // D=D-5
@100 // 주소
D; JEQ // If D=0 goto 100
@200 // 주소 
0; JMP // goto 200
```

## 4.2.4 기호

- 어셈블리 명령은 상수나 기호를 이용해서 메모리 위치(주소) 참조 가능
- 미리 정의된 기호(predefined symbol)
    - 가상 레지스터 : 기호 R0~R15 → RAM 주소 0~15
    - 미리 정의된 포인터 : SP, LCL, ARG, THIS, THAT → RAM 주소 0~4 (이름 2개)
    - I/O 포인터 : SCREEN → RAM 주소 16384(0x4000), KBD → 24576(0x6000), 스크린 및 키보드의 메모리 매핑 시작 주소
- 레이블 기호(label symbol)
    - goto 명령어의 목적지를 나타냄
    - 사용자가 '(Xxx)'라는 의사명령으로 직접 선언
    - 다음에 실행할 명령을 담고 있는 명령어 메모리 주소를 기호 Xxx로 선언하라
- 변수 기호(variable symbol)
    - 미리 정의된 기호, 레이블 기호 외의 모든 사용자 정의 기호
    - RAM 주소 16(0x0010)에서부터 차례대로 변수마다 유일한 메모리 주소 할당

## 4.2.5 입력/출력 조작

- 핵 플랫폼 - 스크린, 키보드와 연결 가능
- 메모리 맵을 통해 컴퓨터 플랫폼과 통신
- 물리적 I/O 장치와 메모리 맵은 계속 갱신되는 루프를 통해 동기화

### 스크린

- 512열 X 256행의 흑백 픽셀로 구성
- 스크린에 표시되는 픽셀 RAM 주소 16384(0x4000)부터 시작하는 8K(128K?)짜리 메모리 맵에 대응
- 물리적 스크린에서 각 행을 화면의 맨 왼쪽 상단부터 시작
- RAM 내에서는 32개의 연속된 16비트 단어로 표현
- 위에서 r번째 행, 왼쪽에서 c번째 열의 픽셀
    
    ⇒ RAM[16384 + r*32 + c/16]에  위치한 **단어**의 c%16번째 비트로 매핑 
    
- 스크린 가장 왼쪽 위에 16픽셀 길이의 선을 까맣게 칠함
    
    @SCREEN
    
    M=-1 
    

### 키보드

- 핵 컴퓨터는 RAM 주소 24576(0x6000)에 위치한 1 단어 메모리 맵을 통해 물리적 키보드 장치와 통신
- 키보드가 눌릴 때마다, 눌린 키의 16비트 ASCII 코드가 RAM[24576]에 기록

## 4.2.6 구문 규칙과 파일 형식

### 2진 코드 파일

- 컴퓨터의 명령어 메모리에 기계어 프로그램이 로드될 때, 파일의 n번째 라인에 있는 2진 코드가 명령어 메모리의 주소 n에 저장되는 규칙 (프로그램 라인 숫자, 메모리 주소 숫자 모두 0부터 시작)
- .hack 확장자

### 어셈블리 언어 파일

- .asm 확장자
    - 명령어 : A-명령어, C-명령어
    - (Symbol)
        - 다음 명령이 저장되는 메모리 위치에 Symbol 레이블 할당
        - 의사명령 : 실제로 이에 대응하는 기계어 코드 생성X
        

## 프로젝트

### Fill.asm

```c
int cur = SCREEN; 
while(1) {
  // 키보드 push 
  if(memory[KBD] != 0) {
    if(cur < 24576) {
      memory[cur] = 1;
      cur += 1;
    }
  }
  else {
    if(cur > SCREEN) {
      memory[cur-1] = 0;
      cur -= 1;
    }
  } 
}
```
